@echo off & cd /d "%~dp0" & title ET FORENSIC EXTRACTOR & echo [STATUS] Launching Forensic Extraction Protocol... & python -x "%~f0" %* & pause & goto :eof
import os
import sys
import subprocess
import importlib.util
import zipfile
import re

# --- ET FORENSIC CONTAINER EXTRACTOR ---
# STRICT MODE: NO PAGE SCRAPING ALLOWED.
# ONLY EXTRACTS EMBEDDED STREAMS AND FILES.

sys.stdout.reconfigure(encoding='utf-8')

def install_and_import(package, import_name):
    if importlib.util.find_spec(import_name) is None:
        print(f"[*] Installing dependency: {package}...")
        try:
            subprocess.check_call([sys.executable, "-m", "pip", "install", package])
        except subprocess.CalledProcessError:
            print(f"[!] ERROR: Could not install {package}.")
            sys.exit(1)
    return importlib.import_module(import_name)

def main():
    target_file = "ET Math Compendium.pdf"
    output_dir = "compendium_extracted"
    
    if not os.path.exists(target_file):
        print(f"[!] MISSING TARGET: {target_file}")
        sys.exit(1)

    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    print(f"[*] Target: {target_file}")
    files_found = 0

    # --- PROTOCOL 1: ZIP HEADER CHECK ---
    try:
        if zipfile.is_zipfile(target_file):
            print("[*] PROTOCOL 1 (ZIP): Archive Header Detected.")
            with zipfile.ZipFile(target_file, 'r') as z:
                z.extractall(output_dir)
                files_found += len(z.namelist())
            print(f"[+] Extracted {files_found} files via ZIP Protocol.")
            return
    except:
        pass

    # --- PDF PROTOCOLS ---
    try:
        fitz = install_and_import("pymupdf", "fitz")
        doc = fitz.open(target_file)
        
        # --- PROTOCOL 2: STANDARD PORTFOLIO (EmbeddedFiles Name Tree) ---
        print("[*] PROTOCOL 2 (PORTFOLIO): Scanning Name Tree...")
        emb_count = doc.embfile_count()
        for i in range(emb_count):
            try:
                name = doc.embfile_names()[i]
                data = doc.embfile_get(i)
                out_path = os.path.join(output_dir, os.path.basename(name))
                with open(out_path, "wb") as f:
                    f.write(data)
                print(f"   [+] Extracted: {name}")
                files_found += 1
            except Exception as e:
                print(f"   [!] Error: {e}")

        # --- PROTOCOL 3: ANNOTATION ATTACHMENTS (Pinned to Pages) ---
        print("[*] PROTOCOL 3 (ANNOTATIONS): Scanning Page References...")
        for pno in range(doc.page_count):
            page = doc.load_page(pno)
            for annot in page.annots() or []:
                if annot.type[0] == 17: # FileAttachment
                    try:
                        info = annot.file_info
                        filename = info.get("filename", f"annot_p{pno+1}_{files_found}.txt")
                        content = annot.file_get()
                        out_path = os.path.join(output_dir, os.path.basename(filename))
                        with open(out_path, "wb") as f:
                            f.write(content)
                        print(f"   [+] Extracted: {filename}")
                        files_found += 1
                    except:
                        pass

        # --- PROTOCOL 4: FORENSIC OBJECT SCAN (Deep Stream Search) ---
        # This iterates every object in the PDF to find streams marked as EmbeddedFiles
        # that may be missed by the standard catalog.
        print("[*] PROTOCOL 4 (FORENSIC): Scanning Raw Objects...")
        len_xref = doc.xref_length()
        for xref in range(1, len_xref):
            try:
                # We look for dictionaries containing /Type /EmbeddedFile or /Subtype /text/plain
                # but specifically defined as embedded file streams.
                obj_str = doc.xref_object(xref)
                
                # Check for EmbeddedFile type marker in the dictionary
                if "/EmbeddedFile" in obj_str:
                    if doc.is_stream(xref):
                        # Attempt to find a filename in the dictionary or associated FileSpec
                        # This is heuristic; we might just have to name it generically if no name key found.
                        
                        # Try to get stream data
                        data = doc.xref_stream(xref)
                        
                        # Heuristic Naming: check if we already have this file (by size/content)
                        # or generate a name.
                        
                        # Try to parse a name from the object string (e.g. /F (filename.txt))
                        name_match = re.search(r"/F \((.*?)\)", obj_str)
                        if name_match:
                            filename = name_match.group(1)
                        else:
                             # Look for /Unix or /Dos keys
                            name_match = re.search(r"/(Unix|Dos|Mac) \((.*?)\)", obj_str)
                            if name_match:
                                filename = name_match.group(2)
                            else:
                                filename = f"recovered_stream_{xref}.txt"
                        
                        # Sanitize
                        filename = os.path.basename(filename)
                        out_path = os.path.join(output_dir, filename)
                        
                        # Avoid overwriting existing files from Protocol 2/3
                        if not os.path.exists(out_path):
                            with open(out_path, "wb") as f:
                                f.write(data)
                            print(f"   [+] Recovered Forensic Stream: {filename}")
                            files_found += 1
            except:
                continue
        
        doc.close()

    except Exception as e:
        print(f"[!] Engine Error: {e}")

    if files_found > 0:
        print(f"\n[SUCCESS] Total Files Extracted: {files_found}")
        print(f"[*] Output: {os.path.abspath(output_dir)}")
    else:
        print("\n[FAILURE] No embedded files found in container.")

if __name__ == "__main__":
    main()