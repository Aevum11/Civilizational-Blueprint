#!/usr/bin/env python3
"""
Exception Theory Web Tracer and Downloader v1.8
The Complete ET-Derived Web Manifold Navigator with GUI and Logging

Enhanced troubleshooting:
- Logs sys.path, directory contents, and dir(ETMathV2/ETMathV2Descriptor) after import.
- Checks for methods with hasattr and falls back if missing.
- Better error handling for imports with detailed logs.
- Output defaults to script dir.

All generated files in script dir by default.

Author: Derived from Michael James Muller's Exception Theory
Version: 1.8 (2026-02-03)
"""

import os
import sys
import hashlib
import subprocess
import webbrowser
import logging
from urllib.parse import urljoin, urlparse
from typing import List, Dict, Set, Optional, Any

def main():
    # Get script directory for all file operations
    script_dir = os.path.dirname(os.path.abspath(__file__))
    
    # Setup Logging in Script Directory
    log_path = os.path.join(script_dir, 'et_downloader.log')
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(log_path),
            logging.StreamHandler(sys.stdout)
        ]
    )
    logger = logging.getLogger(__name__)
    logger.info(f"Script started. Log file: {log_path}")
    logger.info(f"Script directory: {script_dir}")
    logger.info(f"Current working directory: {os.getcwd()}")
    logger.info(f"sys.path: {sys.path}")

    # List contents of script_dir for troubleshooting
    try:
        dir_contents = os.listdir(script_dir)
        logger.info(f"Contents of script_dir: {dir_contents}")
    except Exception as e:
        logger.error(f"Failed to list script_dir: {str(e)}")

    # GUI Import (Standard Library)
    try:
        import tkinter as tk
        from tkinter import filedialog, messagebox
        logger.info("Tkinter imported successfully.")
    except ImportError as e:
        logger.error(f"Tkinter import failed: {str(e)}")
        messagebox.showerror("Import Error", f"Tkinter not found: {str(e)}")
        return

    # Function to check and install missing modules
    def install_missing_modules(modules: List[str]):
        """
        Verify and install needed components using pip.
        Derived from ET: Recursive discovery of missing descriptors (modules) and substantiation (installation).
        """
        for module in modules:
            try:
                __import__(module)
                logger.info(f"Module {module} already installed.")
            except ImportError:
                logger.warning(f"Module {module} missing. Attempting installation.")
                try:
                    subprocess.check_call([sys.executable, '-m', 'pip', 'install', module])
                    logger.info(f"Successfully installed {module}.")
                except Exception as e:
                    logger.error(f"Failed to install {module}: {str(e)}")
                    messagebox.showerror("Installation Error", f"Failed to install {module}: {str(e)}\nPlease install manually.")

    # Install required external libraries if missing
    required_modules = ['requests', 'beautifulsoup4']
    install_missing_modules(required_modules)

    # Now safe to import
    try:
        import requests
        from bs4 import BeautifulSoup
        logger.info("requests and bs4 imported successfully.")
    except ImportError as e:
        logger.error(f"Import failed after installation attempt: {str(e)}")
        return

    # Adjust sys.path to include local exception_theory
    sys.path.insert(0, script_dir)
    logger.info(f"Added {script_dir} to sys.path for local imports.")
    logger.info(f"Updated sys.path: {sys.path}")

    # Import ET Core Components (Required for ET-Derived Math)
    ETMathV2 = None
    ETMathV2Descriptor = None
    Point = None
    Descriptor = None
    Traverser = None
    bind_pdt = None
    BASE_VARIANCE = 0.0833  # Default fallback
    MANIFOLD_SYMMETRY = 12  # Default fallback
    try:
        from exception_theory.core import mathematics
        ETMathV2 = mathematics.ETMathV2
        from exception_theory.core import mathematics_descriptor
        ETMathV2Descriptor = mathematics_descriptor.ETMathV2Descriptor
        from exception_theory.core.primitives import Point, Descriptor, Traverser, bind_pdt
        from exception_theory.core.constants import BASE_VARIANCE, MANIFOLD_SYMMETRY
        logger.info("Successfully imported exception_theory components.")
        # Log dir for troubleshooting
        logger.info(f"dir(ETMathV2): {dir(ETMathV2)}")
        logger.info(f"dir(ETMathV2Descriptor): {dir(ETMathV2Descriptor)}")
    except ImportError as e:
        logger.error(f"Failed to import exception_theory: {str(e)}")
        # List contents of exception_theory if exists
        et_dir = os.path.join(script_dir, 'exception_theory')
        if os.path.exists(et_dir):
            logger.info(f"Contents of exception_theory dir: {os.listdir(et_dir)}")
            core_dir = os.path.join(et_dir, 'core')
            if os.path.exists(core_dir):
                logger.info(f"Contents of core dir: {os.listdir(core_dir)}")
        # Attempt setup.py install
        setup_path = os.path.join(script_dir, 'setup.py')
        if os.path.exists(setup_path):
            try:
                subprocess.check_call([sys.executable, setup_path, 'install'], cwd=script_dir)
                logger.info("Installed via setup.py. Retrying import.")
                from exception_theory.core import mathematics
                ETMathV2 = mathematics.ETMathV2
                from exception_theory.core import mathematics_descriptor
                ETMathV2Descriptor = mathematics_descriptor.ETMathV2Descriptor
                from exception_theory.core.primitives import Point, Descriptor, Traverser, bind_pdt
                from exception_theory.core.constants import BASE_VARIANCE, MANIFOLD_SYMMETRY
                logger.info("Retry import successful.")
                logger.info(f"dir(ETMathV2): {dir(ETMathV2)}")
                logger.info(f"dir(ETMathV2Descriptor): {dir(ETMathV2Descriptor)}")
            except Exception as install_e:
                logger.error(f"Installation via setup.py failed: {str(install_e)}")
                messagebox.showerror("ET Library Error", "Failed to import or install exception_theory. Check logs for details.")
        else:
            logger.error(f"setup.py not found at {setup_path}")
            messagebox.showerror("ET Library Error", "setup.py not found. Ensure proper placement.")
        # Fallback if still failed
        if ETMathV2 is None:
            class Point:
                def __init__(self, location): self.location = location
            class Descriptor:
                def __init__(self, name, constraint): self.name = name; self.constraint = constraint
            class Traverser:
                def __init__(self, identity, current_point): self.identity = identity; self.current_point = current_point
            def bind_pdt(p, d, t): pass
            logger.warning("Using fallback primitives.")

    # Standard replacements for missing ET math methods
    def simple_manifold_hash(data: bytes) -> str:
        return hashlib.sha256(data).hexdigest()

    def simple_cardinality(n: int) -> int:
        return min(n * 2, MANIFOLD_SYMMETRY)

    def simple_variance_checker(original_hash: str, downloaded_data: bytes) -> float:
        computed = simple_manifold_hash(downloaded_data)
        return 0.0 if computed == original_hash else 1.0

    def simple_recursive_descriptor_discovery(data: str) -> List[Dict]:
        # Fallback: Parse with BS4 for 'href' and 'src'
        soup = BeautifulSoup(data, 'html.parser')
        descs = []
        for elem in soup.find_all(['a', 'img', 'link', 'script']):
            attr = 'href' if elem.name in ('a', 'link') else 'src'
            if elem.has_attr(attr):
                descs.append({attr: elem[attr]})
        return descs

    # Initialize derived functions with checks
    has_et_math = ETMathV2 is not None
    has_et_desc = ETMathV2Descriptor is not None
    if has_et_math:
        try:
            test_hash = ETMathV2.manifold_hash(b'test')
            logger.info("ETMathV2.manifold_hash tested OK.")
        except AttributeError:
            has_et_math = False
            logger.warning("ETMathV2.manifold_hash missing. Using fallback.")
    if has_et_desc:
        try:
            et_desc = ETMathV2Descriptor()
            test_desc = et_desc.recursive_descriptor_discovery('<a href="test">')
            logger.info("ETMathV2Descriptor.recursive_descriptor_discovery tested OK.")
        except AttributeError:
            has_et_desc = False
            logger.warning("ETMathV2Descriptor.recursive_descriptor_discovery missing. Using fallback.")

    # Define functions based on availability
    manifold_hash = ETMathV2.manifold_hash if has_et_math else simple_manifold_hash
    cardinality_calc = ETMathV2.cardinality if has_et_math else simple_cardinality
    variance_checker = integrity_variance_checker if has_et_math else simple_variance_checker
    recursive_desc = lambda data: ETMathV2Descriptor().recursive_descriptor_discovery(data) if has_et_desc else simple_recursive_descriptor_discovery(data)

    class ETWebTraverser(Traverser if Point else object):
        def __init__(self, identity: str, starting_url: str):
            if Point:
                super().__init__(identity=identity, current_point=Point(location=starting_url))
            else:
                self.identity = identity
                self.current_point = {'location': starting_url}
            self.downloaded = {}
            self.hashes = {}
            self.variances = {}
            logger.info(f"Initialized ETWebTraverser for {starting_url}")
        
        def traverse_and_substantiate(self, url: str) -> Optional[bytes]:
            try:
                logger.info(f"Traversing to {url}")
                response = requests.get(url, timeout=10)
                response.raise_for_status()
                content = response.content
                
                # ET Binding if available
                if bind_pdt:
                    url_point = Point(location=url)
                    content_desc = Descriptor(name="web_content", constraint=len(content))
                    bind_pdt(url_point, content_desc, self)
                
                # Hash and Verify
                content_hash = manifold_hash(content)
                self.hashes[url] = content_hash
                
                variance = variance_checker(content_hash, content)
                self.variances[url] = variance
                logger.info(f"Variance for {url}: {variance}")
                
                if variance > BASE_VARIANCE:
                    raise ValueError(f"High variance ({variance}) at {url}")
                
                self.downloaded[url] = content
                return content
            
            except Exception as e:
                logger.error(f"Traversal error at {url}: {str(e)}")
                return None
        
        def discover_resources(self, html_content: str, base_url: str) -> Set[str]:
            try:
                logger.info(f"Discovering resources from {base_url}")
                descriptors = recursive_desc(html_content)
                links = set()
                for desc in descriptors:
                    if isinstance(desc, dict):
                        url = desc.get('href') or desc.get('src')
                        if url:
                            full_url = urljoin(base_url, url)
                            links.add(full_url)
                # Simple recurse if depth needed, but limit to 1 for safety
                return links
            except Exception as e:
                logger.error(f"Resource discovery failed: {str(e)}")
                return set()
        
        def download_all(self, base_url: str, output_dir: str) -> Dict[str, Any]:
            try:
                os.makedirs(output_dir, exist_ok=True)
                logger.info(f"Created output directory: {output_dir}")
                
                html_content = self.traverse_and_substantiate(base_url)
                if not html_content:
                    raise RuntimeError(f"Failed to substantiate base URL: {base_url}")
                
                main_path = os.path.join(output_dir, 'index.html')
                with open(main_path, 'wb') as f:
                    f.write(html_content)
                logger.info(f"Saved main HTML to {main_path}")
                
                resources = self.discover_resources(html_content.decode('utf-8', errors='ignore'), base_url)
                logger.info(f"Discovered {len(resources)} resources")
                
                estimated_card = cardinality_calc(len(resources))
                if len(resources) > estimated_card:
                    logger.warning(f"Resource cardinality exceeds bound ({len(resources)} > {estimated_card})")
                
                for res_url in resources:
                    content = self.traverse_and_substantiate(res_url)
                    if content:
                        parsed = urlparse(res_url)
                        res_path = os.path.join(output_dir, parsed.path.lstrip('/')) or 'resource'
                        os.makedirs(os.path.dirname(res_path), exist_ok=True)
                        with open(res_path, 'wb') as f:
                            f.write(content)
                        logger.info(f"Saved resource to {res_path}")
                
                report = {
                    'base_url': base_url,
                    'total_resources': len(resources),
                    'downloaded_count': len(self.downloaded),
                    'variances': self.variances,
                    'hashes': self.hashes,
                    'estimated_cardinality': estimated_card,
                    'manifold_symmetry': MANIFOLD_SYMMETRY
                }
                logger.info(f"Download report: {report}")
                return report, main_path
            except Exception as e:
                logger.error(f"Download all failed: {str(e)}")
                raise

    def run_gui():
        root = tk.Tk()
        root.withdraw()
        
        url = tk.simpledialog.askstring("Input URL", "Enter the webpage URL:")
        if not url:
            logger.error("URL input cancelled.")
            messagebox.showerror("Error", "URL is required.")
            return
        logger.info(f"User entered URL: {url}")
        
        output_dir = filedialog.askdirectory(title="Select Output Folder", initialdir=script_dir)
        if not output_dir:
            logger.error("Output folder selection cancelled.")
            messagebox.showerror("Error", "Output folder is required.")
            return
        logger.info(f"User selected output dir: {output_dir}")
        
        traverser = ETWebTraverser(identity="web_crawler", starting_url=url)
        
        try:
            report, local_path = traverser.download_all(url, output_dir)
            messagebox.showinfo("Success", f"Download Complete.\nTotal Resources: {report['total_resources']}\nDownloaded: {report['downloaded_count']}\nOpening in browser...")
            logger.info("Download successful. Opening browser.")
            webbrowser.open(f"file://{os.path.abspath(local_path)}")
        except Exception as e:
            logger.error(f"Critical Error in download: {str(e)}")
            messagebox.showerror("Error", f"Critical Error: {str(e)}")

    run_gui()

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"Critical error: {str(e)}")
    finally:
        print("Program completed. Press Enter to exit.")
        input()